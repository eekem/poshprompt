generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id              String            @id
  name            String
  email           String            @unique
  emailVerified   Boolean           @default(false)
  image           String?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  role            String?
  banned          Boolean?          @default(false)
  banReason       String?
  banExpires      DateTime?
  username        String?           @unique
  displayUsername String?
  prompts         Int               @default(0)
  earnedBalance   Float             @default(0.0)
  earnedXps       Int               @default(0)
  accounts        Account[]
  payments        Payment[]
  sessions        Session[]
  fingerprints    UserFingerprint[]
  miniModels      MiniModel[]
  buildingToolsSessions BuildingToolsSession[]
  buildingSessions BuildingSession[]
  builds          Build[]

  @@map("user")
}

model Session {
  id             String   @id
  expiresAt      DateTime
  token          String   @unique
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  ipAddress      String?
  userAgent      String?
  userId         String
  impersonatedBy String?
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}

model Jwks {
  id         String    @id
  publicKey  String
  privateKey String
  createdAt  DateTime
  expiresAt  DateTime?

  @@map("jwks")
}

model Challenge {
  id            String   @id @default(uuid())
  title         String
  description   String
  goal          String?  // V2: Challenge goal
  difficulty    String?  // V2: Beginner/Intermediate/Advanced
  version       Int      @default(1)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Challenge configuration stored in JSON
  task         Json?    // Challenge task definition
  gameplay     Json?    // Gameplay configuration
  scoring      Json?    // Scoring configuration
  rewards      Json?    // Rewards configuration
  
  isActive     Boolean  @default(true)
  isFeatured   Boolean  @default(false)
  
  // New evaluation system fields
  rewardZoneType String  @default("top_n")
  rewardZoneValue Int   @default(3)
  totalPrizePool Float? @default(80.0)
  
  // Minimum build power requirement
  minimumBuildPower Float? @default(0.0)
  
  // Relationships
  builds          Build[]
  buildingSessions BuildingSession[]
  buildingToolsSessions BuildingToolsSession[]
  miniModels   MiniModel[]
  rewardEligibilities RewardEligibility[]
  challengePrizes ChallengePrizes[]

  @@map("challenge")
}


model BuildingToolsSession {
  id          String   @id @default(cuid())
  sessionId   String   @unique
  challengeId String
  userId      String
  options     Json     // Store the 6 building tool options
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([challengeId])
  @@index([userId])
  @@map("building_tools_session")
}

model ChallengePrizes {
  id        String   @id @default(cuid())
  challengeId String
  position  Int      // 1st, 2nd, 3rd
  amount    Float
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  challenge Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  @@map("challenge_prizes")
}

model Payment {
  id                String   @id @default(cuid())
  userId            String
  amount            Float
  currency          String
  status            String
  reference         String   @unique
  paystackReference String?
  metadata          Json?
  promptsPurchased  Int
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([reference])
  @@map("payment")
}

model UserFingerprint {
  id          String   @id @default(cuid())
  userId      String
  fingerprint String
  userAgent   String?
  ip          String?
  device      String?
  browser     String?
  os          String?
  screen      String?
  timezone    String?
  language    String?
  isTrusted   Boolean  @default(false)
  lastSeen    DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, fingerprint])
  @@index([userId])
  @@index([fingerprint])
  @@map("user_fingerprint")
}

model MiniModel {
  id             String   @id @default(cuid())
  userId         String
  challengeId    String
  sessionId      String   @unique
  title          String
  description    String?
  image          String?
  systemPrompt   String
  finalScore     Float
  robustnessScore Float
  totalXp        Int
  coinsEarned    Int
  isPublic       Boolean  @default(false)
  isPublished    Boolean  @default(false)
  publishedAt    DateTime?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  // New evaluation system fields
  tier           String?  // "Platinum", "Gold", "Silver", "Bronze"
  percentile     Float?   // 0.0 - 1.0 representing percentile rank
  isRewardEligible Boolean @default(false)
  internalRank   Int?     // Internal ranking (hidden from users)
  
  // Cumulative model features (stored as JSON)
  cumulativeFeatures Json?  // {robustness: number, accuracy: number, stability: number, creativity: number, efficiency: number}
  recommendedStrategy Json? // Auto-selected strategy based on challenge goals
  
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  challenge      Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  rewardEligibility RewardEligibility?

  @@map("mini_model")
}

model RewardEligibility {
  id          String   @id @default(cuid())
  challengeId String
  miniModelId String   @unique
  position    Int      // 1st, 2nd, 3rd, etc.
  prizeAmount Float?
  isEligible  Boolean  @default(false)
  calculatedAt DateTime @default(now())
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  miniModel   MiniModel @relation(fields: [miniModelId], references: [id], onDelete: Cascade)

  @@map("reward_eligibility")
}

// New models for session-based building system

model BuildingSession {
  id          String   @id @default(cuid())
  challengeId String
  userId      String
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Session-specific generated content
  categories  SessionCategory[]
  pointMap    SessionPointMap?
  builds      Build[]
  tools       SessionTool[]
  
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("building_session")
}

model SessionCategory {
  id          String   @id @default(uuid())
  slug        String
  title       String
  session     BuildingSession @relation(fields: [sessionId], references: [id])
  sessionId   String
  tools       SessionTool[]
  createdAt   DateTime @default(now())

  @@map("session_category")
}

model SessionTool {
  id          String   @id @default(uuid())
  slug        String
  title       String
  description String
  icon        String
  promptCost  Int
  // V2 features for this tool
  features    Json?    // Store tool features (robustness, accuracy, etc.)
  category    SessionCategory @relation(fields: [categoryId], references: [id])
  categoryId  String
  session     BuildingSession @relation(fields: [sessionId], references: [id])
  sessionId   String
  createdAt   DateTime @default(now())

  @@map("session_tool")
}

model SessionPointMap {
  id                    String   @id @default(uuid())
  v2Data                Json?    // Complete v2 data structure
  archetypes            Json?    // Archetype definitions
  platformMetadata      Json?    // Platform metadata
  session               BuildingSession @relation(fields: [sessionId], references: [id])
  sessionId             String   @unique
  createdAt             DateTime @default(now())

  @@map("session_point_map")
}

model Build {
  id            String   @id @default(uuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id])
  challenge     Challenge @relation(fields: [challengeId], references: [id])
  challengeId   String
  session       BuildingSession @relation(fields: [sessionId], references: [id])
  sessionId     String
  selectedTools Json
  strength      Float
  // V2 fields
  v2ScoringResult Json?  // Complete v2 scoring breakdown
  selectedArchetype Json? // Selected archetype for this build
  createdAt     DateTime @default(now())

  @@map("build")
}
