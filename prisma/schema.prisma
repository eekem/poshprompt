generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id              String            @id
  name            String
  email           String            @unique
  emailVerified   Boolean           @default(false)
  image           String?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  role            String?
  banned          Boolean?          @default(false)
  banReason       String?
  banExpires      DateTime?
  username        String?           @unique
  displayUsername String?
  prompts         Int               @default(0)
  earnedBalance   Float             @default(0.0)
  earnedXps       Int               @default(0)
  accounts        Account[]
  chats           Chat[]
  payments        Payment[]
  sessions        Session[]
  fingerprints    UserFingerprint[]
  miniModels      MiniModel[]
  publications    MiniModelPublication[]
  buildingToolsSessions BuildingToolsSession[]
  buildingSessions BuildingSession[]
  builds          Build[]

  @@map("user")
}

model Session {
  id             String   @id
  expiresAt      DateTime
  token          String   @unique
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  ipAddress      String?
  userAgent      String?
  userId         String
  impersonatedBy String?
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}

model Jwks {
  id         String    @id
  publicKey  String
  privateKey String
  createdAt  DateTime
  expiresAt  DateTime?

  @@map("jwks")
}

model Challenge {
  id            String   @id @default(uuid())
  title         String
  description   String
  version       Int      @default(1)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Legacy fields for backward compatibility
  gameType     String?
  difficulty   String?
  modelType    String?
  modelName    String?
  task         Json?
  gameplay     Json?
  scoring      Json?
  rewards      Json?
  maxXpPerTurn Int      @default(100)
  minScore     Int      @default(0)
  isActive     Boolean  @default(true)
  isFeatured   Boolean  @default(false)
  week         String?
  
  // New evaluation system fields
  rewardZoneType String  @default("top_n")
  rewardZoneValue Int   @default(3)
  totalPrizePool Float? @default(80.0)
  
  // Relationships
  builds          Build[]
  buildingSessions BuildingSession[]
  buildingToolsSessions BuildingToolsSession[]
  
  // Legacy relationships
  chats        Chat[]
  stressTests  StressTest[]
  miniModels   MiniModel[]
  weeklyRotations WeeklyRotation[]
  rewardEligibilities RewardEligibility[]
  challengePrizes ChallengePrizes[]

  @@map("challenge")
}

model Chat {
  id          String    @id @default(cuid())
  userId      String
  challengeId String
  isActive    Boolean   @default(true)
  currentTurn Int       @default(1)
  totalScore  Int       @default(0)
  earnedXp    Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages    Message[]
  miniModel   MiniModel?
  stressResults StressTestResult[]
  buildingToolsSession BuildingToolsSession?

  @@index([userId])
  @@index([challengeId])
  @@map("chat")
}

model Message {
  id         String   @id @default(cuid())
  chatId     String
  type       String
  content    String
  prompt     String?
  output     String?
  score      Int?
  breakdown  Json?
  turnNumber Int
  createdAt  DateTime @default(now())
  chat       Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@index([chatId])
  @@index([type])
  @@map("message")
}

model BuildingToolsSession {
  id          String   @id @default(cuid())
  chatId      String   @unique
  challengeId String
  userId      String
  options     Json     // Store the 6 building tool options
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  chat        Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([chatId])
  @@index([challengeId])
  @@index([userId])
  @@map("building_tools_session")
}

model ChallengePrizes {
  id        String   @id @default(cuid())
  challengeId String
  position  Int      // 1st, 2nd, 3rd
  amount    Float
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  challenge Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  @@map("challenge_prizes")
}

model Payment {
  id                String   @id @default(cuid())
  userId            String
  amount            Float
  currency          String
  status            String
  reference         String   @unique
  paystackReference String?
  metadata          Json?
  promptsPurchased  Int
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([reference])
  @@map("payment")
}

model UserFingerprint {
  id          String   @id @default(cuid())
  userId      String
  fingerprint String
  userAgent   String?
  ip          String?
  device      String?
  browser     String?
  os          String?
  screen      String?
  timezone    String?
  language    String?
  isTrusted   Boolean  @default(false)
  lastSeen    DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, fingerprint])
  @@index([userId])
  @@index([fingerprint])
  @@map("user_fingerprint")
}

model StressTest {
  id          String   @id @default(cuid())
  challengeId String
  testCase    String
  testType    String   // adversarial, edge_case, contradictory, extreme_constraint, out_of_distribution
  expected    Json?    // Expected response pattern
  weight      Float    @default(1.0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  results     StressTestResult[]

  @@map("stress_test")
}

model StressTestResult {
  id          String   @id @default(cuid())
  stressTestId String
  chatId      String
  miniModelId String
  output      String
  score       Float
  passed      Boolean
  breakdown   Json?
  createdAt   DateTime @default(now())
  stressTest  StressTest @relation(fields: [stressTestId], references: [id], onDelete: Cascade)
  chat        Chat       @relation(fields: [chatId], references: [id], onDelete: Cascade)
  miniModel   MiniModel  @relation(fields: [miniModelId], references: [id], onDelete: Cascade)

  @@map("stress_test_result")
}

model MiniModel {
  id             String   @id @default(cuid())
  userId         String
  challengeId    String
  chatId         String   @unique
  title          String
  description    String?
  image          String?
  systemPrompt   String
  finalScore     Float
  robustnessScore Float
  totalXp        Int
  coinsEarned    Int
  isPublic       Boolean  @default(false)
  isPublished    Boolean  @default(false)
  publishedAt    DateTime?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  // New evaluation system fields
  tier           String?  // "Platinum", "Gold", "Silver", "Bronze"
  percentile     Float?   // 0.0 - 1.0 representing percentile rank
  isRewardEligible Boolean @default(false)
  internalRank   Int?     // Internal ranking (hidden from users)
  
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  challenge      Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  chat           Chat      @relation(fields: [chatId], references: [id], onDelete: Cascade)
  stressResults  StressTestResult[]
  publications   MiniModelPublication[]
  rewardEligibility RewardEligibility?

  @@map("mini_model")
}

model MiniModelPublication {
  id          String   @id @default(cuid())
  miniModelId String
  publisherId String
  publishedAt DateTime @default(now())
  downloads   Int      @default(0)
  rating      Float?   @default(0)
  reviews     Int      @default(0)
  miniModel   MiniModel @relation(fields: [miniModelId], references: [id], onDelete: Cascade)
  publisher   User      @relation(fields: [publisherId], references: [id], onDelete: Cascade)

  @@map("mini_model_publication")
}

model WeeklyRotation {
  id           String   @id @default(cuid())
  week         String   @unique // e.g., "2026-W07"
  theme        String
  featuredId   String
  activeIds    Json     // Array of challenge IDs
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  featuredChallenge Challenge @relation(fields: [featuredId], references: [id])

  @@map("weekly_rotation")
}

model RewardEligibility {
  id          String   @id @default(cuid())
  challengeId String
  miniModelId String   @unique
  position    Int      // 1st, 2nd, 3rd, etc.
  prizeAmount Float?
  isEligible  Boolean  @default(false)
  calculatedAt DateTime @default(now())
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  miniModel   MiniModel @relation(fields: [miniModelId], references: [id], onDelete: Cascade)

  @@map("reward_eligibility")
}

// New models for session-based building system

model BuildingSession {
  id          String   @id @default(cuid())
  challengeId String
  userId      String
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Session-specific generated content
  categories  SessionCategory[]
  pointMap    SessionPointMap?
  builds      Build[]
  tools       SessionTool[]
  
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("building_session")
}

model SessionCategory {
  id          String   @id @default(uuid())
  slug        String
  title       String
  session     BuildingSession @relation(fields: [sessionId], references: [id])
  sessionId   String
  tools       SessionTool[]
  createdAt   DateTime @default(now())

  @@map("session_category")
}

model SessionTool {
  id          String   @id @default(uuid())
  slug        String
  title       String
  description String
  icon        String
  promptCost  Int
  category    SessionCategory @relation(fields: [categoryId], references: [id])
  categoryId  String
  session     BuildingSession @relation(fields: [sessionId], references: [id])
  sessionId   String
  createdAt   DateTime @default(now())

  @@map("session_tool")
}

model SessionPointMap {
  id                    String   @id @default(uuid())
  baseMultiplier        Float
  categoryDiversityBonus Int
  maxStrength           Int
  synergyRules          Json
  session               BuildingSession @relation(fields: [sessionId], references: [id])
  sessionId             String   @unique
  createdAt             DateTime @default(now())

  @@map("session_point_map")
}

model Build {
  id            String   @id @default(uuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id])
  challenge     Challenge @relation(fields: [challengeId], references: [id])
  challengeId   String
  session       BuildingSession @relation(fields: [sessionId], references: [id])
  sessionId     String
  selectedTools Json
  strength      Float
  createdAt     DateTime @default(now())

  @@map("build")
}
